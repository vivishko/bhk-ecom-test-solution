<p align="center">
  Тестовое в БХК-ЕКОМ (Xsolla)
</p>

## Task 1. Задание

Нужно сделать сервис, который будет считать клики по баннерам и собирать их в поминутную статистику (timestamp, bannerID, count)

Полное описание [в папке docs в файле task](/docs/tasks_description.md#задача-1-счетчик-кликов)

## Tech stack

Backend: Go </br>
Databases and other tools: Postgres

## Решение

логику мыслей описывала в [файле task1_thoughts.md в папке docs](/docs/task1_thoughts.md)

**реализовано решение №3**

пояснения по особенностям реализации:</br>
_microservices (2 services)_: сервис-продюсер содержит 2 ручки, в которые можно "постучаться" извне, при инкрементации каунтера этот сервис посылает сообщения в кафку; сервис консумер с заданной периодичностью собирает сообщения из кафки, обрабатывает и складывает в нужном формате в бд</br>
_migrations_: миграции в бд описаны в папке migrations, "накатываются" автоматически при запуске docker compose</br>
_kafka_: она здесь для распределения нагрузки на сервисы и повышения отказоустойчивости</br>
_gin_</br>
_docker+docker compose_: для удобного разворачивания и запуска приложения</br>
_graphana+prometheus+k6_: для сбора метрик и удобного отображения в виде графиков на дашбордах (ну и из интереса), также для проведения нагрузочного тестирования, чтобы понять какой rps выдерживает система</br>

минусы и плюсы решения описаны в том же [файле task1_thoughts.md в папке docs](/docs/task1_thoughts.md)

## Инструкция по использованию

1. склонировать репо

По ssh

```bash
$ git clone git@github.com:vivishko/bhk-ecom-test-solution.git
```

По https

```bash
$ git clone https://github.com/vivishko/bhk-ecom-test-solution.git
```

2. настроить окружение: создать файл .env в корне проекта, скопировать туда содержание .example.env и изменить значения переменных на существующие (или оставить как есть)</br>
   здесь MINUTES_TICKER это период (в минутах), за который консюмер будет собирать сообщения из кафки (то есть если MINUTES_TICKER=5, то данные в бд обновляются каждые 5 минут, соответственно gap в актуальности может быть 5 минут)

3. запустить проект через docker compose up

```bash
$ docker compose up
```

**Результат:**

- для инкрементации каунтера кликов можно сделать POST-запрос на http://localhost:8080/stats/:bannerId
- для сбора статистики сделать GET-запрос на http://localhost:8080/stats/:bannerId с телом вида:

```bash
{
    "tsFrom": "2024-12-10T12:56:00Z",
    "tsTo": "2024-12-10T12:57:59Z"
}
```

**Нагрузочное тестирование и метрики:**

- данные по rps можно посмотреть в дашборде graphana, перейдя по http://localhost:3000
- провести нагрузочное тестирование можно с помощью утилиты k6 и скрипта load-stress-test.js
- перед началом необходимо установить k6 - подробнее об установке [на сайте](https://grafana.com/docs/k6/latest/set-up/install-k6/) </br>
- запустить тест можно командой

```bash
$ k6 run load-test.js
```

- пояснения по скрипту: </br>
  **stages** описывает стадии проведения теста </br>
  **target** обозначает количество виртуальных юзеров (VU) </br>
  **thresholds** описывают критерии, при которых тест считается пройденным: в данном случае это [95% запросов должны выполняться за <200ms] и [не более 1% запросов с ошибкой] </br>
  **sleep(0.1)** задаёт паузу между запросами для виртуального пользователя (этим мы увеличиваем максимальный проверяемый rps с 500 до 5000)

## TODO
